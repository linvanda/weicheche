
1. 微信端的代码问题：
    1. controller 里面有过多的业务代码，model 基本是查询数据库的贫血类（而且很多方法很相似）。业务逻辑没有做很好的封装。
如 CardCenterController 有 3000 行。
出现大 Controller（以及其它类）的原因是类命名太概括（从类的名称看不出具体的职责，或者说可以负责很多很多功能），比如 CardCenterController，卡中心，范围太广。
建议的做法是缩小类命名范围，做到专精（创建类的时候当你想用**Center 的时候，往往是个错误的决定，而像 User、Member 等大概念的使用也需谨慎）。
例如 CardCenterController 中关于用户密码的部分可以独立成 PasswordController，用户注册、登录、激活可以独立成 Authcontroller 或 SignController,账户相关独立成 UserAccountController 等。
    2. Controller 中的方法体过大，多个方法之间存在大量重复代码。
出现这种情况的原因除了业务逻辑代码泄露到 Controller 中以外，还因为“展示逻辑”过于复杂(如 CardCenterController::index)，需要将模型层（业务逻辑）返回的模型数据转换成适合页面展示用的展示数据，这些逻辑显然不适合放在 Model 中。
当遇到复杂的展示处理逻辑时，可以创建一个或多个“展示模型”来处理这些逻辑，Controller 中协调调用这些展示模型。注意展示模型和业务模型的区别：展示模型不处理业务逻辑，它调用一个或多个业务模型（Model、Logic）并对它们返回的数据进行组装、转换，以适合视图层使用。
    3. controller 中调用其它 controller 中的方法，这是不推荐的做法。
    4. controller 中直接写 sql（不多，估计是临时处理型方法）。
    5. model 中直接写的原生 sql，如：
SELECT * FROM wei_group_config WHERE group_id = $group_id AND isvalid = 1 …
此处的 $group_id 是这样获取的： $group_id = $_GET[‘group_id’]。存在 sql 注入风险。
建议使用框架提供的 方法组装 sql 语句。
    6. openid 保存在 session 中。此处存在业务场景漏洞：
当用户在一次会话（同一个 sessionid）中切换不同的公众号，就会出现 openid 串号。
当用户先进入 A 公众号（第一次进），此时会去微信获取 openid 并存储到 session 中。然后 用户在进入 B 公众号，此时服务器检查发现 session 中存在 openid，于是取该 openid，但该openid 是
用户在 A 公众号的 openid。
解决方法：没有什么好的解决方法（cookie 等都不行），只能通过在所有 url 中带标示（如 openid 或其它可识别用户的标示），如果没有带，则需要去微信获取。
（根据邓聪所说，现在很多商户的用户 openid 用的是大号（喂车车的）的 openid，在此中模式下这里没有问题，因为不管哪个公众号，用的 openid 都是一样的，但这会带来其它更严重的问题，微信相关功能如群发、模板消息等用不了，所以现在采用二次授权机制）。
    7. Model层：几乎都是对数据库的操作代码，如 UserModel 中的 getUserBy***，每个查询都是一个方法，导致过于臃肿的、重复性的代码（UserModel 有近 1300 行代码，几乎都是各种 select）。
目前 thinkphp 这边是把 Model 作为 sql 查询功能用，真正的业务逻辑写在 Logic 中，这种方式也可以，但 Model 中不应该存在大量基本重复的代码，相关方法可以抽取成一个。
    8. 方法和类很少有注释，再加上封装的缺失，导致后人很难维护。
    9. 方法的编写：存在重复性代码，可优化重构（如 CardLogic.class.php 的 getBaseConfig）。
    10. 普遍地，方法和类过长。
导致此问题的原因是抽象不够，整体的 OO 设计和持续的重构不够。
建议当方法或类过长时，进行拆分重构，将一个大方法拆分成多个小方法（或类），其中业务无关逻辑抽离到辅助类中。
通过多个类的组合/继承来实现复杂的业务，必要时可抽离出更高层次的服务类（Service）。
    11. 一些配置直接写在类中（如 Logic/KeysLogic.class.php）。
建议将配置性的东西统一写在配置文件中。
    12. 类职责划分不明，比如 KeysLogic 类职责是处理（跟 ss）密钥和加密相关的事情，但其中却有个 send 方法用于发送数据。
    13. 缺少统一状态码管理机制，状态码直接写死在代码中。 
建议的做法是，每个项目有自己统一的状态码定义文件（如以常量的形式），代码中禁止直接写诸如 200 的数字状态码，而是写常量（CARD_APPLY_SUC 比 200 更一目了然，后人看到到处的 200 300可能摸不着头脑。另外，和外部合作时，状态码管理文件提供了一层外界变化隔离机制——谁都不能保证对方不会改变其状态码的含义）。
    14. 代码风格不统一，如 if 后面的左大括号，有些是放在同一行，有些是换行的。
    15. 关于超链接：目测都是用的相对链接地址，直接写的。后期重构（拆分系统）时会出现麻烦，需要各个地方改。
建议采用配置（baseUrl 部分）加类库封装调用，禁止直接拼接 Url。
    16. 业务模型中包含非业务功能代码，如 CreditModel 中的 encryptUCode 和 decryptUCode 方法。这两个方法属于业务领域无关的功能，应当放到基础支撑层的辅助类/函数中。
    17. WPApi.class.php：负责各子系统的服务注册、路由与请求。
这些功能最好公司有统一的、独立的 api 网关服务器负责，WPApi只请求统一的网关接口，由网关服务器负责服务注册、路由、鉴权、限流等职责。
    18. 上帝类：
如 UserLogic，有 2300 多行，其中包括了获取/更新用户基本信息、优惠渠道相关、消费/交易相关、微信用户相关等，以及非业务代码如加解密。
建议：功能拆分，每个类职责单一，然后可以采用服务类（Service）或聚合/组合的方式对外提供复杂功能。
    19. 微信接口调用：
        1. 没有进行很好的封装，很多功能都是放在 WechatAdv 里面，比如里面有好几个发送模板消息的方法（send_***_message），内容几乎一样，需要重构。
    20. 没有用缓存，如用户信息可以使用缓存提高效率。而且用户基本信息即没有放到缓存里面也没有放到 session 里面，是每次直接从数据库查的，一次请求会重复查询多次。
    21. 访问统计：
        1. 直接操作数据库的（一次查询一次写入），量大的话会造成数据库压力。
        2. 是在各各控制器中调用该方法的。访问统计这种应当有统一处理机制。
        3. 优化：
            1. 改成缓存或消息队列写入；
            2. 不要在各自控制器直接调用，应当有统一调用处理机制，并且要保证该方法不会抛异常导致业务失败，也不会造成业务组赛（如消息队列服务器请求堵塞），即先让页面返回，而后 PHP 继续执行（方法自行百度）。
            3. 如果是为了统计页面访问量，可以采用第三方统计（简单的如腾讯统计这种，精细点的如收费的 growIO）。
    22. 公共 Controller：
        1. 一些不属于公共控制器的功能放在里面了，如支付宝授权相关，用户绑定、授权、验证码等，应当归专门的类管理。
    23. 配置信息缺乏统一的管理。如 VipCardController::getCommonInfo() 里面直接写死的。（包括 WPApi 也是）
    24. 像 openid、userInfo 这种几乎所有控制器都要用到的，最好在基类控制器统一获取并放到属性上（或通过其它方式可方便直接用），不用每个控制器都写上
$openid = $this->_getUserOpenId();
$user_info = D("Users")->getUserByOpenid($openid);
    25. 根据业务场景提取不同的基类控制器，如需要登录才能访问的、游客可访问的等，然后一些统一的逻辑（如用户没有注册就跳转到注册页面）放在基类处理，不用各个控制器重复写。
    26. 例如这样的代码出现在很多 action 中：
        $openid = $this->_getUserOpenId();
        $group_id = A("CardCenter")->getGroupId();
        A("VipCard")->getCommonInfo($group_id);
        $group_info = D("VipCard")->getGroupByGroupid($group_id);
        $agreement_type = 3;
        $is_reg         = 1;
        $platform       = 'WECHAT';
        $merchant_type  = 2;
        $merchant_id    = $group_id;
        $uid            = 0;

        if ($group_info === false || count($group_info) === 0) {
            $this->status = 500;
            $this->info = "参数错误，找不到集团信息";
            $this->display("CardCenter:error");
            exit;
        }
        $user_info = D("Users")->getUserByOpenid($openid);
        if (count($user_info) === 0) {
            //如果找不到用户，需要先注册
            $agreement_type = 1;
            $is_reg = 0;
            $this->getUserAgreementBase($merchant_type, $merchant_id, $agreement_type, $uid, $platform, $is_reg, 1);
            $this->status = 456;
            $this->info = "需要先注册";
            $this->display("CardCenter:register_user");
            exit();
        }
27. 数据库连接信息直接写在 控制器中：ActivityController


其它问题：
1. 没有统一的开发环境，新来的员工必须自己搭建。更重要的，每个人的开饭环境不统一；
建议：统一开发环境。有几种方案：
    1. 使用 vagrant。团队使用统一的 vagrant box 开发。box 纳入版本管理，如当需要安装一个 php 扩展时，更新该 box，然后所有成员下载更新后的 box 更新本地开发环境（laravel 项目可以直接使用 Homestead, thinkphp 也可以用，但要改下重写规则）；
    2. 使用 docker。创建/下载统一的image，有修改需要时更新 image。不过比 vagrant 机制稍复杂（可使用 docker composer 简化管理）。
    3. 统一采用远程开发环境，即有一个远程集中的开发服务器，本地不需要安装开发环境，只需要一个 IDE，用 IDE 的 sftp 连接远程开发（代码是实时同步的）。这种方式对于微信开发很有用
（开发环境在外网）。在开发服务器上，每个人是一个单独的开发目录。
2. 分支管理。项目底下分支太多（都有一百多个）。
建议：建立统一的分支管理方案，可参考 gitflow，或者我之前团队采用的方案（也是借鉴并简化 gitflow）：https://github.com/linvanda/iflow
3. 日志。必须登录到服务器上查看日志，不方便。
建议：使用公司的 ELK 日志系统。